# Урок 3. Ускоренная обработка данных: 
# lambda, filter, map, zip, enumerate, list comprehension
# --------------------------------------------------------------------------------------------------
# Анонимные, lambda функции:
# def sum(x):
#     return x+10 # x+22  # x+242

# def mult(x):
#     return x**2 # x**3  # x**5

# sum(mult(2)) 
# Чтобы не описывать в явную функции, которые используются только один раз,
# можно использовать анонимные lambda функции.

# def f(x):
#     x**2
# g = f
# print(f(1))
# print(type(f)) # <class 'function'>
# print(g(1))
# Так как можно функцию положить в переменную, значит я могу в качестве аргумента какой-то функции передать функцию.
# def f(x):
#     return x**2
# print(f(2)) # 4 
# К примеру, её я использовал (делал вызов) один раз, можно сократить код.
# def f(x):
#     return x**2
# g = f # Положил (передал) функцию в переменную. Работа она будет так же как f.
# # т.е. у меня есть переменная которая хранит в себе ссылку на функцию.
# print(type(f)) # <class 'function'>
# print(type(g)) # <class 'function'>

# print(f(4))
# print(g(4))

# def calc1(x):
#     return x+10
# print(calc1(10)) # 20

# def calc2(x):
#     return x*10
# print(calc2(10)) # 100

# def math(op, x):
#     print(op(x))
# math(calc2, 10) # 100
# math(calc1, 10) # 20
# Пример с двумя переменными.
# def sum(x, y):
#     return x+y
# f = sum
# sum = lambda x, y: x+y # Это тоже мамое, что и выше на три строчки!!!
# А дальше можно пропустить шаг создание отдельной переменной и сразу в качестве аргумента пробрасывать lambda.
# def mult(x, y):
#     return x*y


# def calc(op, a, b):
#     print(op(a, b))
#     # return op(a, b)

# # calc(mult, 4, 5) # 20
# # calc(f, 4, 5) # 9
# # calc(sum, 4, 5) # 9
# calc(lambda x, y: x+y, 4, 5) # 9
# -------------------------------------------------------------------------------------------------
# list Comprehension - Нужен он, чтобы быстро создавать списки.
# [exp for item in iterable]
# [exp for item in iterable (if conditional)] # Создание списка по условию
# [exp <if conditional> for item in iterable (if conditional)]
# Разберу первый пример написания [exp for item in iterable]

# list = []
# for i in range(1, 101):
#     # if(i%2 == 0): # Выборка идет только четных чисел.
#         list.append(i)
# print(list) # покажет только четные числа
# print(list) ## покажет все числа от 1 до 100.

# list = [i for i in range(1, 101)] # Запись в одну строку.
# print(list) # покажет все числа от 1 до 100.
# list = [i for i in range(1, 101) if i%2 == 0] 
# print(list) # покажет только четные числа
# Допустим, мне нужно показать пару каждого из чисел (включаю кортежи).
# list = [(i, i) for i in range(1, 101) if i%2 == 0] 
# print(list) # покажет список кортежей. # [(2, 2), (4, 4),...(98, 98), (100, 100)]
# Так же можно обрабатывать данные, т.е. указывать не просто само значение аргумента, 
# а взять какую нибудь функцию:
# def f(x):
#     return x**3
# list = [f(i) for i in range(1, 101) if i % 2 == 0]
# print(list) # Возведение четных значений в степень. # [8, 64,...941192, 1000000]
# Для наглядности подключу кортежи:
# def f(x):
#     return x**3
# list = [(i, f(i)) for i in range(1, 101) if i % 2 == 0]
# print(list) # Число и его куб # [(2, 8), (4, 64),..(100, 1000000)]
# Подлючу lambda.
# ЗАДАЧА: В файле храняться числа, нужно выбрать четные и составить список пар (число; квадрат числа).
# Пример:
# 1 2 3 5 8 15 23 38
# Получить:
# [(2, 4), (8, 64), (38, 1444)]
# РЕШЕНИЕ---------------------------------------------------------------------------------
# path = '/Users/User/Desktop/Python_Language/lessons/file.txt' # Важно!!! Обращать внимание на мелочи.
# f = open(path, 'r')
# data = f.read() + ' ' # Считываю все строчки и добавляю пробел, для 
# f.close() # Закрываю фаил.

# numbers = [] # Создал список, в который буду наполнять.
# while data != '': # Пробегаю по всей строке и делаю проверку пока моя строка не пустая. 
#     space_pos = data.index(' ') # Дальше моя задача, найти первую позицию пробела, 
#     numbers.append(int(data[:space_pos])) # Взять всё что находиться, от первого символа до позиции первого пробеза и превратить это в число, и добавить в список номеров(numbers).
#     data = data[space_pos + 1:] # Обновить строку, с учётом того, что, то что уже проверено, больше проверять не нужно.
# out = [] # Создаю новый список.
# for e in numbers: # Проверяю условие, что число является четным.
#     if not e % 2:
#         out.append((e, e **2)) # Добавляю в новый список кортежа, где первая координата (e) - само число, (e**2) - квадрат этого числа. 
# print(out) # [(2, 4), (8, 64), (38, 1444)]
# ------------------------------------------------------------------------------------------
# Можно ли код написать лучше?
# def select(f, col):
#     return [f(x) for x in col]

# def where(f, col):
#     return [x for x in col if f(x)]

# data = '1 2 3 5 8 15 23 38'.split()

# res = select(int, data) # print(res) # [1, 2, 3, 5, 8, 15, 23, 38]
# res = where(lambda x: not x%2, res) # print(res) # [2, 8, 38]
# res = select(lambda x: (x, x**2), res) # [(2, 4), (8, 64), (38, 1444)]
# print(res) 
# -------------------------------------------------------------------------------------------
# Простые функции типо (select, where), есть в Python.
# Функция map() применяет указанную функцию к каждому элементу итерируемого объекта
# и возвращает итератор с новыми объектами.
# f(x) -> x + 10
# map(f, [1, 2, 3, 4, 5])
#         ↓  ↓  ↓  ↓  ↓ 
#       [11, 12, 13, 14, 15]
# Нельзя пройтись дважды
# li = [x for x in range(1, 20)]
# # print(li) # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
# li = list(map(lambda x: x+10, li))
# print(li) # [11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29]
# -----------------------------------------------------------------------------------------
# Допустим, с квавиатуры вводятся числа, в качестве разделителя пробел.
# data = list(map(int,input().split()))
# print(data) # [1, 2, 3, 45, 67]
# Можно не писать list (приведение к типу), а сразу пробежаться по объектам
# data = map(int,input().split())
# data = map(int, '1 2 3 4 555 6'.split()) # С list лучше т.к. сразу есть сохранение данных.
# for e in data:
#     print(e)
# print('--')

# for e in data:
#     print(e)
# ---------------------------------------------------------------------------------------------
# def where(f, col):
#     return [x for x in col if f(x)]

# data = '1 2 3 4 5 8 23 38'.split()

# res = map(int, data)
# res = where(lambda x: not x % 2, res)
# res = list(map(lambda x: (x, x**2), res))
# print(res) # [(2, 4), (4, 16), (8, 64), (38, 1444)]
# ----------------------------------------------------------------------------------------------
# Что бы избавиться от функции where в Python есть функция filter.
# ---------------------------------------------------------------------------------------------
# Функция filter() применяет указанную функцию к каждому элементу итерируемого объекта и
# возвращает итератор с теми объектами, для которых функция вернула True.
# f(x) -> x  - чётное
# filter(f, [1, 2, 3, 4, 5])
#               ↓     ↓
#              [2,    4]
# Нельзя пройтись дважды.
# data = [x for x in range(10)]

# res = list(filter(lambda x: not x % 2, data))

# print(res) # [0, 2, 4, 6, 8]
# ----------------------------------------------------------------------------------------
# data = '1 2 3 4 5 8 23 38'.split()

# res = map(int, data)
# res = filter(lambda x: not x % 2, res)
# res = list(map(lambda x: (x, x**2), res))
# print(res) # [(2, 4), (4, 16), (8, 64), (38, 1444)]
# --------------------------------------------------------------------------------------------
# Функция zip() применяется к набору итерируемых объектов и возвращает итератор с 
# кортежами из элементов входных данных.
# Пример:
# Количество элементов в результате равно минимальному количеству элементов входного набора
# zip ([1, 2, 3], ['о', 'д', 'т'], ['f', 's', 't'])
# [(1, 'о', 'f'), (2, 'д', 's'), (3, 'т', 't')]
# Нельзя пройтись дважды
# Пример:------------------------------------------------------------------------------------------
# users = ['user1', 'user2', 'user3', 'user4', 'user5']
# ids = [4, 5, 9, 14, 7]
# salary = [111, 222, 333]

# # data = list(zip(users, ids))
# # print(data) # [('user1', 4), ('user2', 5), ('user3', 9), ('user4', 14), ('user5', 7)]
# data = list(zip(users, ids, salary))
# print(data) # [('user1', 4, 111), ('user2', 5, 222), ('user3', 9, 333)]
# ------------------------------------------------------------------------------------------------
# Если мне потребуется пронумеровать мой список, я могу взять два исходных и попорядку через range 
# подмешать zip и просчитать, но есть уже готовая функция в Python enumerate().
# Функция enumerate() применяется к итерируемому
# объекту и возвращает новый итератор с кортежами
# из индекса и элементов входных данных.
# enumerate(['Казань', 'Смоленск', 'Рыбки', 'Чикаго'])
#                         ↓
# [(0, 'Казань'), (1, 'Смоленск'), (2, 'Рыбки'), (3, 'Чикаго')]
# Нельзя пройтись дважды 
# -----------------------------------------------------------------------------------------------
users = ['user1', 'user2', 'user3', 'user4', 'user5']
ids = [4, 5, 9, 14, 7]
salary = [111, 222, 333]

data = list(enumerate(users))
print(data) # [(0, 'user1'), (1, 'user2'), (2, 'user3'), (3, 'user4'), (4, 'user5')]


